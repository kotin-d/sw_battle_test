Тут  будут описываться этапы

1.  Планируется приличное количество кода, следовательно нужны юнит-тесты.  Настоящая система потянет кучу зависимостей.  Поэтому будет использовать кривую, но рабочую поделку, похожую на юниты, развивая ее по необходимости в процессе.

2.  Несмотря на то, что существует принцип YAGNI, мы его будем безжалостно нарушать. Но при этом описывать почему (фантазируя,  что мы это действительно слышали и это действительно будет в приложении в будущем).

3.  Добавляем бизнес-объекты.
    Предположения,  которые нарушают YAGNI
    - карта будет показываться на экране
    - на карте будет ландшафт (лес,  горы,  высота,  стены и все такое)
    - число фигур на карте будет расширяться,  это не только мечник и лучник,  их будет намного больше

4.  Похоже, что класс Map это синглетон. Все признаки на это указывают.  Но будем тянуть до последнего с переводом его в синглетоны,  и сделаем это лишь если будет реально необходимо. Не люблю синглетоны.

5.  Накидав немного разных функций по классам,  начинаем переходить к созданию бизнес-объектов.  Заодно понимая что ячейка и фигуры принадлежат карте.

6.  Время добавить в команды необходимые действия.

7.  Понимаем,  что не существует отдельных понятий X и Y, а есть только позиция (которая состоит из X и Y)

8.  Существует множество вариантов расчета дискретного пути. Для ряда вариантов расчета математически невозможно расщитать остаток пути на каждом шаге. Нужно сразу высчитывать весь дискретный путь. При этом знаем,  что правила расчета могут быть разными.  Появиться класс рыцарь, который будет пытаться сначала выйти на прямую,  и потом максимально быстро сказать на цель, и другие варианты.  Поэтому начинаем иерархию расчетов пути.  Конечно,  это опять нарушает YAGNI,  но смотри пункт 3

9.  Отладил линейный генератор пути,  накидал на него пару тестов.  Нужно будет сравнить его с генератором,  который предполагается в задаче.  Даже у линейного генератора могут быть небольшие отличия в генерации пути

10. Персонажи не должны жить на карте.  Карта сущность которая не знает о ходах и времени.  А персонажи живут на сцене, к которой привязана карта.  Исправляем эту ошибку,  и делаем первые ходы в игре.

11. Поменяли немного интерфейсы и генераторы пути. По тестам стало понятнее, как их лучше использовать.  Приступаем к разработке стратегий атаки. Алгоритмы поиска цели отлаживаем в юнит-тестах.

12. Сформировав стратегии атаки, начинаем все компоновать вместе.  В начальной заготовке использовались исключения. Спор о том плохо это или хорошо, отложим, так же будем использовать исключения, когда приходят явно кривые внешние данные.
Map перестает быть синглетоном,  но им становиться сцена. Дополняем карту и сцену делегатами. Делегат,  это набор обратных вызовов. В нашем примитивном делегате, который будем подставлять и реализовано логирование результата
(в рабочем делегате оповещение графики и других систем).

13. Приходит понимание,  что нам нужен какой-то хитрый контейнер для хранения фигур.  Который может делать быстрый поиск по id и по позиции.  boost_multiindex подходит на такую роль,  но он в бусте.  Вариант через Cell, дает константный поиск
по координате за счет разряженного массива.  Быстрый поиск по id оставим пока в тех долге (так как нужно еще сохранить порядок поступления фигур).

14. Наша сцена является родиной делегатов.  В большой реальной задаче это не так,  но для такого варианта считаю этого достаточно.  Выпрямляем ситуацию с делегатами.  Дополнительно приходим к простой мысли, что нам нужен вектор с id фигур,
который будет отвечать за порядок поступления объекта.  А так же хеш-таблица для самих объектов в сцене.  Тогда будет быстрый доступ по id и знаем порядок поступления объектов.

15.  Переносим все необходимое, что ошибочно было в карте, на сцену. Карта остается картой, которая не знает о ходах и прочем.  Заодно меняем действия в командах, теперь все пляшет от сцены.

16.  Все создается, пути считаются, есть заготовки для атак,  приступаем к главному игровому циклу.

17.  Пробуем пока только движение и окончание игры.  Для этого поработаем с разными вариантами входных файлов.  Появляется стойкое ощущение, что класc сцены это в реальности класс Game.

18.  Поймали ошибку, что порядок вычисления аргументов передаваемых в функции не определен. Но после движение персонажей заработало полностью, что удивило

19.  Атака у нас раньше хода,  причем так,  что мы если клетка занята, то мы ее ударим, а не в нее сходим.  Поэтому проверка на занятость клетки пока не нужна.

20.  В основе атак лежит функция поиска фигур на конкретном расстоянии.  Мы должны найти все возможные фигуры и ударить именно по случайной (или позже определить какое-то другое правило выборы атакуемой фигуры).
Поэтому разбиваем атаку на два компонента - finder и selector, компоновкой который,  можно будет получить Attacker

21.  Сделали два атакера,  ближнего боя и лучника.  Видим что виртуальность нам особо не нужна,  мы не уточняем поведение,  а обобщаем.
и теперь попробуем обратиться к дополнительным фигурам,  попробуем понять что с ними и как
Башня - есть hp, значит умирает и получает урон.  Имеет атаку лучника и пустой генератор пути.  Вроде все просто
Лекарь - ходит, умирает, но аттаку производит иначе.  Нужен компонент производителя атаки.
мина - свой финдер, не ходит, атака вроде типовая, но в два этапа, имеет состояния взвода
ворон, свое перемещение, свой обнаружитель с правилами и дистанцией
Итого нам нужны следующие ортогональные группы стратегий.
а) производители атак, у мага отличия
б) свой обнаружитель.  Термин нужно придумать. Это возможность получить атаку с такого-то места и такого-то типа. Ее нужно передавать в поисковик целей
в) свой получатель атаки, для будущего.  Где внутри жизнь, и анализ смерти.  Получатель атаки и производитель атаки связаны.
Самое сложное придумать термины.
Hiter - производитель атаки.  То что делает удар.
Hper - то что принимает урон, и анализирует состояние жизни-смерти
Reacher - стратегия что можно достать атакой фигуру.
Placer - занимает ли место (хотя, кажется он излишний) это просто bool и ничего в нем нет.  Но есть лажа, что в клетке могут быть две фигуры

Так, все вроде стало логично.  Нужно сделать иерархии компонентов-стратегий и посмотреть как будет вырождаться виртуальность в обобщение.

22.  Немного распрямляем код.  Стратегий много, они маленькие, уменьшим число файлов. Переименуем Hper в Healther. Hiter в Damager. Параллельно начинаем делать документацию

23.  Вывод информации об атаке, заставляет нас автономный атакер разделить на две части, на выбор цели и причинение урона.

24.  Реализовали двойной диспачер.  Для каждого типа поиска есть своя скрытность.  Спасибо ворону, которого нельзя убить ближеней атаке, и дальней он поражается с условиями.

25. Переименуем в конце концов фигуру в юнит.
